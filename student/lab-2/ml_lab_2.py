# -*- coding: utf-8 -*-
"""ml-lab-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kcVdCWboD2PV4OTrGSuf2jTLpl6s6pud
"""

import numpy as np
import pandas as pd
import pandasql as ps
import seaborn as sns
import warnings
import time

# %matplotlib inline 
import matplotlib.pyplot as plt


warnings.filterwarnings('ignore')
pd.set_option('display.max.columns', 100)

data = pd.read_csv('./sample_data/adult.txt')
data.head()

#all dataframe columns
data.columns

#1. How many men and women (sex feature) are represented in this dataset?
data.sex.value_counts()

#2. What is the average age (age feature) of women?
women = data.loc[data.sex == 'Female', 'age']
women.mean()

#3. What is the percentage of German citizens (native-country feature)?
germans = data.loc[data.nativeCountry == 'Germany']
germanPercentage = float(germans.age.sum() / data.shape[0]) * 100
germanPercentage

#4. What are the mean and standard deviation of age for those who earn more than 50K per year (salary feature)?
richPeoples = data.loc[data.salary == '>50K']
richAges = richPeoples.age
richAges.std()

#5. What are the mean and standard deviation of age for those less than 50K per year (salary feature)?
poorPeoples = data.loc[data.salary == '<=50K'] 
poorAges = poorPeoples.age
poorAges.std()

#6. Is it true that people who earn more than 50K have at least high school education? (education â€“ Bachelors, Prof-school, Assoc-acdm, Assoc-voc, Masters or Doctorate feature)
richPeoples.education.unique()

#7. Display age statistics for each race (race feature) and each gender (sex feature). Use groupby() and describe().
for (race, sex), sub_df in data.groupby(['race', 'sex']):
    print("Race: {0}, sex: {1}".format(race, sex))
    print(sub_df.age.describe())

#8. Among whom the proportion of those who earn a lot(>50K) is more: among married or single men (marital-status feature)? 
#Consider married those who have a marital-status starting with Married (Married-civ-spouse, Married-spouse-absent or Married-AF-spouse), the rest are considered bachelors.
notMariedStatuses = ['Never-married', 'Separated', 'Divorced', 'Widowed']
notMariedMen = data.loc[(data.sex == 'Male') & (data.maritalStatus.isin(notMariedStatuses)), 'salary']
notMariedMen.value_counts()

mariedMen = data.loc[(data.sex == 'Male') & data.maritalStatus.str.startswith('Married'), 'salary']
mariedMen.value_counts()

#9. What is the maximum number of hours a person works per week (hours-per-week feature)? 
#How many people work such a number of hours, and what is the percentage of those who earn a lot (>50K) among them?
maxLoad = data.hoursPerWeek.max()
print("Max time - {0} hours./week.".format(maxLoad))

numWorkaholics = data[data.hoursPerWeek == maxLoad].shape[0]
print("Total number of such hard workers {0}".format(numWorkaholics))

richWorkaholics = data[(data.hoursPerWeek == maxLoad) & (data.salary == '>50K')]
richShare = float(richWorkaholics.shape[0]) / numWorkaholics
print("Percentage of rich among them {0}%".format(100 * richShare))

#10. Count the average time of work (hours-per-week) for those who earn a little and a lot (salary) for each country (native-country). What will these be for Japan?
pd.crosstab(data.nativeCountry, data.salary, values=data.hoursPerWeek, aggfunc=np.mean).T

data_devices = pd.read_csv('./sample_data/user_device.csv')
data_devices.head()

data_usage = pd.read_csv('./sample_data/user_usage.csv')
data_usage.head()

def timing(f):
    def wrap(*args):
        time1 = time.time()
        ret = f(*args)
        time2 = time.time()
        print('{:s} function took {:.3f} ms'.format(f.__name__, (time2-time1)*1000.0))

        return ret
    return wrap

@timing
def pandas_merge():
  merged_data = data_devices.merge(data_usage, 'inner', on='use_id')
  return merged_data
  
@timing
def pandasql_merge(devices,usage):
  simple_query = '''
    SELECT *
    FROM devices JOIN usage
    WHERE devices.use_id==usage.use_id     
    '''
  ps.sqldf(simple_query, locals())
  
@timing
def pandas_group(devices_usage):
  devices_usage.groupby('device').monthly_mb.mean()
  
@timing
def pandasql_group(devices_usage):
  aggr_query = '''
    SELECT distinct device, avg(monthly_mb) as avg_mb
    FROM devices_usage 
    GROUP BY device
  '''
  return ps.sqldf(aggr_query, locals())

devices_usage = pandas_merge()
pandasql_merge(data_devices, data_usage)
pandas_group(devices_usage)
pandasql_group(devices_usage)